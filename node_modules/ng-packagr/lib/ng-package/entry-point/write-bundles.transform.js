"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeBundlesTransform = void 0;
const ora_1 = __importDefault(require("ora"));
const path_1 = require("path");
const rollup_1 = require("../../flatten/rollup");
const transform_1 = require("../../graph/transform");
const cache_1 = require("../../utils/cache");
const fs_1 = require("../../utils/fs");
const nodes_1 = require("../nodes");
const writeBundlesTransform = (options) => (0, transform_1.transformFromPromise)(async (graph) => {
    const entryPoint = graph.find((0, nodes_1.isEntryPointInProgress)());
    const { destinationFiles, entryPoint: ngEntryPoint, tsConfig } = entryPoint.data;
    const cache = entryPoint.cache;
    const { fesm2020Dir, fesm2015Dir, esm2020 } = destinationFiles;
    const spinner = (0, ora_1.default)({
        hideCursor: false,
        discardStdin: false,
    });
    const key = await (0, cache_1.generateKey)(ngEntryPoint.moduleId, esm2020, fesm2020Dir, fesm2015Dir, tsConfig.options.compilationMode);
    const hash = await (0, cache_1.generateKey)([...cache.outputCache.values()].map(({ version }) => version).join(':'));
    const cacheDirectory = options.cacheEnabled && options.cacheDirectory;
    if (cacheDirectory) {
        const cacheResult = await (0, cache_1.readCacheEntry)(options.cacheDirectory, key);
        if ((cacheResult === null || cacheResult === void 0 ? void 0 : cacheResult.hash) === hash) {
            try {
                spinner.start('Writing FESM bundles');
                await Promise.all([(0, fs_1.mkdir)(fesm2020Dir, { recursive: true }), (0, fs_1.mkdir)(fesm2015Dir, { recursive: true })]);
                for (const file of cacheResult.fesm2020) {
                    await (0, fs_1.writeFile)((0, path_1.join)(fesm2020Dir, file.fileName), file.type === 'asset' ? file.source : file.code);
                }
                for (const file of cacheResult.fesm2015) {
                    await (0, fs_1.writeFile)((0, path_1.join)(fesm2015Dir, file.fileName), file.type === 'asset' ? file.source : file.code);
                }
                spinner.succeed('Writing FESM bundles');
            }
            catch (error) {
                spinner.fail();
                throw error;
            }
            return;
        }
    }
    async function generateFESM(rollupCache, dir, downlevel) {
        const { cache: rollupFESMCache, files } = await (0, rollup_1.rollupBundleFile)({
            sourceRoot: tsConfig.options.sourceRoot,
            entry: esm2020,
            entryName: ngEntryPoint.flatModuleFile,
            moduleName: ngEntryPoint.moduleId,
            dir,
            downlevel,
            cache: rollupCache,
            cacheDirectory,
            fileCache: cache.outputCache,
            cacheKey: await (0, cache_1.generateKey)(esm2020, dir, ngEntryPoint.moduleId, tsConfig.options.compilationMode),
        });
        return {
            /** The map contents are in an asset file type, which makes storing the map in the cache as redudant. */
            files: files.map(f => {
                if (f.type === 'chunk') {
                    f.map = null;
                }
                return f;
            }),
            rollupCache: options.watch ? rollupFESMCache : undefined,
        };
    }
    const fesmCache = {
        hash,
    };
    try {
        spinner.start('Generating FESM2020');
        const { rollupCache, files } = await generateFESM(cache.rollupFESM2020Cache, fesm2020Dir, false);
        cache.rollupFESM2020Cache = rollupCache;
        fesmCache.fesm2020 = files;
        spinner.succeed();
    }
    catch (error) {
        spinner.fail();
        throw error;
    }
    try {
        spinner.start('Generating FESM2015');
        const { rollupCache, files } = await generateFESM(cache.rollupFESM2015Cache, fesm2015Dir, true);
        cache.rollupFESM2015Cache = rollupCache;
        fesmCache.fesm2015 = files;
        spinner.succeed();
    }
    catch (error) {
        spinner.fail();
        throw error;
    }
    if (cacheDirectory) {
        await (0, cache_1.saveCacheEntry)(cacheDirectory, key, JSON.stringify(fesmCache));
    }
});
exports.writeBundlesTransform = writeBundlesTransform;
//# sourceMappingURL=write-bundles.transform.js.map